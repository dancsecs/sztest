/*
   Golang test helper library: sztest.
   Copyright (C) 2023-2025 Leslie Dancsecs

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

package sztest

import (
	"log"
	"math"
	"strconv"
	"time"
)

const (
	clkSubTime = "150405"
	clkSubDate = "20060102"
	clkSubTS   = clkSubDate + clkSubTime
	clkSubNano = clkSubTS + ".000000000"
)

// ClkFmt represents supported clock formats.
type ClkFmt int

// Clock formats and substitutions.
// Substitution strings allow clock ticks to be referenced in output and
// string assertions. If the corresponding format is enabled, {{clkXXXX#}}
// is replaced with the tick at the given sequence index (#):
//
//	ClkFmtTime  {{clkTime#}} // HHmmSS
//	ClkFmtDate  {{clkDate#}} // YYYYMMDD
//	ClkFmtTS    {{clkTS#}}   // YYYYMMDDHHmmSS
//	ClkFmtNano  {{clkNano#}} // YYYYMMDDHHmmSS.#########
//	ClkFmtCusA  {{clkCusA#}} // custom format string
//	ClkFmtCusB  {{clkCusB#}} // custom format string
//	ClkFmtCusC  {{clkCusC#}} // custom format string
//
// Multiple substitution formats can be active at once, since the format
// flags are combined bitwise.
const (
	ClkFmtNone ClkFmt = 0         // No formats.
	ClkFmtTime ClkFmt = 1 << iota // {{clkTime#}} = HHmmSS.
	ClkFmtDate                    // {{clkDate#}} = YYYYMMDD.
	ClkFmtTS                      // {{clkTS#}}   = YYYYMMDDHHmmSS.
	ClkFmtNano                    // {{clkNano#}} = YYYYMMDDHHmmSS.#########.
	ClkFmtCusA                    // {{clkCusA#}} = definable format string.
	ClkFmtCusB                    // {{clkCusB#}} = definable format string.
	ClkFmtCusC                    // {{clkCusC#}} = definable format string.

	ClkFmtAll = math.MaxInt // All defined formats.
)

// ClockSetSub replaces the active substitution formats with the specified set.
func (chk *Chk) ClockSetSub(clkFmt ClkFmt) {
	chk.clkSub = clkFmt
}

// ClockAddSub enables an additional substitution format.
func (chk *Chk) ClockAddSub(clkFmt ClkFmt) {
	chk.clkSub |= clkFmt
}

// ClockRemoveSub disables a previously enabled substitution format.
func (chk *Chk) ClockRemoveSub(clkFmt ClkFmt) {
	chk.clkSub &= ^clkFmt
}

// ClockSetCusA defines the format string used for {{clkCusA#}} substitutions.
// The format must follow Go’s time layout conventions.
func (chk *Chk) ClockSetCusA(f string) {
	chk.clkCusA = f
	if f != "" {
		chk.ClockAddSub(ClkFmtCusA)
	} else {
		chk.ClockRemoveSub(ClkFmtCusA)
	}
}

// ClockSetCusB defines the format string used for {{clkCusB#}} substitutions.
// The format must follow Go’s time layout conventions.
func (chk *Chk) ClockSetCusB(f string) {
	chk.clkCusB = f
	if f != "" {
		chk.ClockAddSub(ClkFmtCusB)
	} else {
		chk.ClockRemoveSub(ClkFmtCusB)
	}
}

// ClockSetCusC defines the format string used for {{clkCusC#}} substitutions.
// The format must follow Go’s time layout conventions.
func (chk *Chk) ClockSetCusC(f string) {
	chk.clkCusC = f
	if f != "" {
		chk.ClockAddSub(ClkFmtCusC)
	} else {
		chk.ClockRemoveSub(ClkFmtCusC)
	}
}

// ClockLast returns the most recent timestamp generated by the test clock.
func (chk *Chk) ClockLast() time.Time {
	return chk.clk.lastTS
}

// ClockLastFmtTime returns the most recent clock value formatted as HHmmSS.
func (chk *Chk) ClockLastFmtTime() string {
	return chk.clk.lastTS.Format(clkSubTime)
}

// ClockLastFmtDate returns the most recent clock value formatted as YYYYMMDD.
func (chk *Chk) ClockLastFmtDate() string {
	return chk.clk.lastTS.Format(clkSubDate)
}

// ClockLastFmtTS returns the most recent clock value formatted as
// YYYYMMDDHHmmSS.
func (chk *Chk) ClockLastFmtTS() string {
	return chk.clk.lastTS.Format(clkSubTS)
}

// ClockLastFmtNano returns the most recent clock value formatted as
// YYYYMMDDHHmmSS.#########.
func (chk *Chk) ClockLastFmtNano() string {
	return chk.clk.lastTS.Format(clkSubNano)
}

// ClockLastFmtCusA returns the most recent clock value using the custom A
// format.
func (chk *Chk) ClockLastFmtCusA() string {
	return chk.clk.lastTS.Format(chk.clkCusA)
}

// ClockLastFmtCusB returns the most recent clock value using the custom B
// format.
func (chk *Chk) ClockLastFmtCusB() string {
	return chk.clk.lastTS.Format(chk.clkCusB)
}

// ClockLastFmtCusC returns the most recent clock value using the custom C
// format.
func (chk *Chk) ClockLastFmtCusC() string {
	return chk.clk.lastTS.Format(chk.clkCusC)
}

// ClockNext advances the test clock by one increment and returns the result
// as a time.Time value.
func (chk *Chk) ClockNext() time.Time {
	nextTS := chk.clk.next()
	chk.clkTicks = append(chk.clkTicks, nextTS)

	if chk.clkSub != 0 { //nolint:nestif // Ok.
		idx := strconv.FormatInt(int64(len(chk.clkTicks)-1), base10)

		if chk.clkSub&ClkFmtTime > 0 {
			chk.AddSub("{{clkTime"+idx+"}}", nextTS.Format(clkSubTime))
		}

		if chk.clkSub&ClkFmtDate > 0 {
			chk.AddSub("{{clkDate"+idx+"}}", nextTS.Format(clkSubDate))
		}

		if chk.clkSub&ClkFmtTS > 0 {
			chk.AddSub("{{clkTS"+idx+"}}", nextTS.Format(clkSubTS))
		}

		if chk.clkSub&ClkFmtNano > 0 {
			chk.AddSub("{{clkNano"+idx+"}}", nextTS.Format(clkSubNano))
		}

		if chk.clkSub&ClkFmtCusA > 0 {
			chk.AddSub("{{clkCusA"+idx+"}}", nextTS.Format(chk.clkCusA))
		}

		if chk.clkSub&ClkFmtCusB > 0 {
			chk.AddSub("{{clkCusB"+idx+"}}", nextTS.Format(chk.clkCusB))
		}

		if chk.clkSub&ClkFmtCusC > 0 {
			chk.AddSub("{{clkCusC"+idx+"}}", nextTS.Format(chk.clkCusC))
		}
	}

	return nextTS
}

// ClockNextFmtTime advances the test clock and returns the result formatted
// as HHmmSS.
func (chk *Chk) ClockNextFmtTime() string {
	return chk.ClockNext().Format(clkSubTime)
}

// ClockNextFmtDate advances the test clock and returns the result formatted
// as YYYYMMDD.
func (chk *Chk) ClockNextFmtDate() string {
	return chk.ClockNext().Format(clkSubDate)
}

// ClockNextFmtTS advances the test clock and returns the result formatted
// as YYYYMMDDHHmmSS.
func (chk *Chk) ClockNextFmtTS() string {
	return chk.ClockNext().Format(clkSubTS)
}

// ClockNextFmtNano advances the test clock and returns the result formatted
// as YYYYMMDDHHmmSS.#########.
func (chk *Chk) ClockNextFmtNano() string {
	return chk.ClockNext().Format(clkSubNano)
}

// ClockNextFmtCusA advances the test clock and returns the result formatted
// using the custom CusA format.
func (chk *Chk) ClockNextFmtCusA() string {
	return chk.ClockNext().Format(chk.clkCusA)
}

// ClockNextFmtCusB advances the test clock and returns the result formatted
// using the custom CusB format.
func (chk *Chk) ClockNextFmtCusB() string {
	return chk.ClockNext().Format(chk.clkCusB)
}

// ClockNextFmtCusC advances the test clock and returns the result formatted
// using the custom CusC format.
func (chk *Chk) ClockNextFmtCusC() string {
	return chk.ClockNext().Format(chk.clkCusC)
}

// ClockTick returns the i'th time value that was generated by the test clock.
func (chk *Chk) ClockTick(i int) time.Time {
	if i < 0 || i >= len(chk.clkTicks) {
		log.Panicf("unknown tick index: %d", i)
	}

	return chk.clkTicks[i]
}

// ClockSet assigns a new base time for the test clock and, if provided,
// updates the sequence of increments. When multiple increments are supplied,
// they are applied in order and wrap around once exhausted.
//
// It returns a reset function that restores the clock to its previous state,
// intended for use with defer. Internally, the last time recorded is
// initialized to newTime minus the final increment.
func (chk *Chk) ClockSet(newTime time.Time, inc ...time.Duration) func() {
	savedClk := chk.clk

	if inc == nil {
		inc = chk.clk.inc
	}

	chk.clk = newTstClock(newTime, inc)

	return func() {
		chk.clk = savedClk
	}
}

// ClockOffsetDay shifts the test clock by the specified number of days.
// Negative values move the clock into the past. Optional increments may
// also be supplied, applied in the same cycling manner as ClockSet.
//
// It returns a reset function that restores the clock to its prior state,
// intended for use with defer. Internally, the last time recorded is
// initialized to newTime minus the final increment.
func (chk *Chk) ClockOffsetDay(dayOffset int, inc ...time.Duration) func() {
	t := chk.clk.lastTS

	return chk.ClockSet(t.AddDate(0, 0, dayOffset), inc...)
}

// ClockOffset shifts the test clock by the specified duration. Optional
// increments may also be supplied, applied in the same cycling manner
// as ClockSet.
//
// It returns a reset function that restores the clock to its prior state,
// intended for use with defer. Internally, the last time recorded is
// initialized to newTime minus the final increment.
func (chk *Chk) ClockOffset(d time.Duration, inc ...time.Duration) func() {
	t := chk.clk.nextTS

	return chk.ClockSet(t.Add(d), inc...)
}

type tstClk struct {
	lastTS    time.Time
	nextTS    time.Time
	inc       []time.Duration
	nextIndex int
}

func newTstClock(startAt time.Time, inc []time.Duration) *tstClk {
	if len(inc) < 1 {
		inc = []time.Duration{time.Millisecond}
	}

	return &tstClk{
		lastTS:    startAt.Add(-inc[len(inc)-1]),
		nextTS:    startAt,
		inc:       inc,
		nextIndex: 0,
	}
}

func (clk *tstClk) next() time.Time {
	clk.lastTS = clk.nextTS
	if clk.nextIndex >= len(clk.inc) {
		clk.nextIndex = 0
	}

	clk.nextTS = clk.nextTS.Add(clk.inc[clk.nextIndex])
	clk.nextIndex++

	return clk.lastTS
}
